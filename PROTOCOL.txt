PROTOCOL.txt

GOALS
-Use Diffie-Hellman key exchange as part of public key infrastructure.
-Server should be able to catch modified or random messages. Server should believe that any other message was sent by a legitimate Client.
-Client should be able to catch modified or random messages. Client should believe that any other message was sent by the Server.
-After Server is taken offline, no secrets remain in memory.
-After Client is taken offline, no secrets remain in memory.
-No secret information in the file system is stored in plaintext.

SERVER LOGIN
Files:
    -networking/FBServer.java
Assumptions:

- The threat does not have considerable computing resources, and cannot reliably run many instances of the server at once, even if it is able to obtain a copy.

- The threat has not placed any logging facility on the machine (especially key loggers)

- The SHA-256 hash function is secure
Protocol:
    - User enters in alphanumeric password
    - Password is hashed using SHA-256, a delay of two seconds is given, and then the hash is checked against the recorded hash in the source code.
    - If the two hashes match, server starts running, and the hashed password is stored in memory
    - Plaintext password is stored in a character array which is overwritten shortly after it
      is used to compute a hash
    - Hashed password is overwritten on server exit
Reasoning:
    - We can store password in memory since we assume threat can’t get to it, but make sure to wipe it so that a threat cannot find it in memory after the program stops.
    - 2 second delay prevents rapid password reentry. Can be extended if necessary. Will easily prevent unsophisticated threats from accessing the server.

- If the threat is able to read the source code and determine the location of the hash, the number of guesses expected (if the threat knows that the password is 10 characters) is about 4 * 10^17. Taking (1*10^6) guesses per second (clearly not gonna happen on a single machine) would finish this task in over 12000 years. We can easily increase that by lengthening the password.

SERVER->FILESYSTEM
Files:
    server/ServerBackend.java (methods: writeSecure, readSecure)
Assumptions:
    - A threat cannot access memory while the program is running. We do not take care of issues in this case, including the time it takes to encrypt/decrypt and the presence of the keys used for encryption in memory
    - We rely on the security of the Java Security packages. An example of this is that there is no way to mutate SecretKey objects, so we hope that the memory space of these is overwritten by their built-in functionality.
    - We assume that a threat cannot modify the Java libraries/JVM on the server’s system.
    - We assume that the server has reasonable uptime so that the threat, which can access the computer the server code runs on only when the server is off, does not have access for weeks at a time). This piece will be explained a bit later.
    - AES encryption is secure.
Protocol:
    - Given a string that is the contents of a file that needs to be secured, do the following:
    - Generate a random salt using SecureRandom
    - Feed the salt and the server password (as a char array) to SecretKeyFactory/Secret to generate a new secret key along with a vector of initialization vectors
    - Generate a random number G using SecureRandom between 0 and 256
    - Append G lines of garbage to the front of the string holding the file contents, and then append G to the front of the result
    - Append a hash of the entire string to the front of the file
    - Encrypt the resulting string using AES with Cipher Block Chaining and PKCS5 padding.
    - Store the salt, the initialization vector generated by the AES cipher, and the encrypted file contents in the file.
    - To decrypt, obtain the salt and initialization vector from the first few bytes of the file, then generate the key used again (since the server password will be in memory), and decrypt the contents, stripping out the garbage at the front.
	- Checks for a hash value where one is supposed to be, if not found returns error, or if the hash does not match the rest of the text, returns an error
Reasoning:
    - A salt of 8 bytes is used since this is common practice.
    - The initialization vector has 16-bytes to match the block size of the  AES cipher
    - The reason for generating the lines of garbage is that (theoretically) a threat would be able to learn some information about the social network’s structure if it could reliably determine the number of friends a user has at any point of time. The random garbage is there to make this difficult.
    - AES is used as a standard industry strength symmetric key protocol. The salt helps to make sure that the same key is not used over and over, in which case a threat may be able to determine some information about the number of friends a user has/who those friends are if the same encoding appears twice.

CLIENT<->SERVER
FILES
networking/FBClient.java
networking/FBClientHandler.java

ASSUMPTIONS
-All Java security libraries used are secure.

CLIENT-SERVER AUTHENTICATION, MESSAGE EXCHANGE
(1) Perform Diffie-Hellman key exchange:
(i) Server -> Client: p, where p is a securely generated large prime
(ii) Client and Server both compute symmetric shared secret key
(iii) Server: securely generates a random number for the counter/nonce
(iv) Both client and server generate public/private keys for signing message and
send the public key to the each other

(2) Secure session: message and incremented counter are now encrypted [AES, CBC
mode with PKCS5 padding] creating a SealedObject. SealedObjects are then signed using signing key to create SignedObject.

(3) The receiving end verifies signature and decrypts message. It also checks the ‘counter’ on each message and the timestamp to prevent replay attacks.

(4) End of secure session occurs when user logs out. Clear all secrets from memory by ANDing everything with 0.

DESIGN REASONING
-Public key encryption used to verify Client and Server to each other
-Each message includes a counter and timestamp to prevent replay attacks.

